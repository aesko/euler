---
title: "Project Euler"
output: html_notebook
---

Solutions to problems from [Project Euler](https://projecteuler.net). 


Problem 1
```{r}
a <- 1:999
multi <- which(a %% 3 == 0 | a %% 5 == 0)
sum(a[multi]) # solution 1
```

Problem 2
```{r}

x <- c(1,2)
i <- 3
while ((x[i-1] + x[i-2]) <= 4000000) {
  x[i] <- x[i-1] + x[i-2]
  i <- i+1
}

even <- x[which(x %% 2 == 0)]
even
sum(even) # solution 2
```

Problem 3
```{r}
# WRONG ANSWER (the small number found is actually not a factor of the large number)

num <- 600851475143
# which small integers is the number of interest divisible by
x <- 2:500
divisible <- num %% x == 0
# the smallest divisible number will lead us to the greatest factor (num/small)
small <- min(which(divisible == T))


# function to test for prime numbers (https://stackoverflow.com/a/19767707)
is.prime <- function(n) n == 2L || all(n %% 2L:max(2,floor(sqrt(n))) != 0)

# let's test if the big number is prime
is.prime(num/small) # TRUE -> got lucky here

num/small # solution 3 


```


Problem 4
```{r}
# function to check whether a number is a palindrome
is.palindrome <- function(x) {
  txt <- as.character(x)
  output <- vector(mode = "logical", length = ceiling(nchar(txt)/2))
  for (i in 1:ceiling(nchar(txt)/2)) {
    ifelse(substring(txt, i, i) == substring(txt, nchar(txt)-(i-1), nchar(txt)-(i-1)),
           output[i] <- T,
           output[i] <- F)
  }
  !any(output == F)
}


x <- 999*999
i <- 1:999
# iterate until first factor is 1) palindrome, 2) divisible with integer and has three digits and 
# 3) the second factor has three digits

while (!is.palindrome(x) | max(which(x%%i==0)) < 100 | x/max(which(x%%i==0)) > 999) {
  x <- x -1
}

max(which(x%%i==0)); x/max(which(x%%i==0)) # the two 3-digit numbers that make the largest palindrome
max(which(x%%i==0)) * x/max(which(x%%i==0)) # solution 4
```

Problem 5
```{r}
x <- 2520
cond <- 1:20
while(any(x%%cond != 0)){
  x <- x+20
}

x # solution 5
```

Problem 6
```{r}
sum(1:100)^2 - sum((1:100)^2) # solution 7
```

Problem 7
```{r}
# function to test for prime numbers (https://stackoverflow.com/a/19767707)
is.prime <- function(n) n == 2L || all(n %% 2L:max(2,floor(sqrt(n))) != 0)
x <- vector(mode = "integer", length = 10001)
i <- 2
n <- 1
while(n <= 10001){
  if(is.prime(i)){x[n] <- i; n<-n+1; i<-i+1} else {i<-i+1 }
}

x[10001] # solution 7
```

Problem 8
```{r}
txt <- "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"

# function that calculates the product of integers in a string (txt)
seq_mult <- function(x) {
  prod(as.integer(strsplit(x, split="")[[1]]))
}

biggest <- 0
biggest_i <- 0
for (i in 1:988) {
  score <- seq_mult(substr(txt, i, i+12))
  if(score > biggest) {biggest <- score; biggest_i <- i}
  
}

prod <- seq_mult(substr(txt, biggest_i, biggest_i+12))
prod # solution 8
```

Problem 9
a+b+c=1000
a^2 + b^2= c^2
a+b+sqrt(a^2+b^2)=1000

```{r} 
x <- c(0,0,0)
for (i in 1:400) {
  for (j in 1:600) {
    if(i+j + sqrt(i^2+j^2)==1000){x[1] <- i; x[2] <-j; x[3] <- 1000-(i+j)}
  }
}

sum(x) # should be 1000
x[1]^2+x[2]^2 == x[3]^2 # should be TRUE
prod(x) # solution 9
```

Problem 10
```{r}
# function to test for prime numbers (https://stackoverflow.com/a/19767707)
is.prime <- function(n) n == 2L || all(n %% 2L:max(2,floor(sqrt(n))) != 0)

x <- c(2,3)
i <- 3
a <- 5
while(a<2e6){
  if(is.prime(a)) {x[i] <- a; i <- i+1}
  a <- a+1
}

sum(x) # solution 10
```

Problem 11
```{r}
dat <- c(08, 02, 22, 97, 38, 15, 00, 40, 00, 75, 04, 05, 07, 78, 52, 12, 50, 77, 91, 08, 
49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 04, 56, 62, 00, 
81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 03, 49, 13, 36, 65, 
52, 70, 95, 23, 04, 60, 11, 42, 69, 24, 68, 56, 01, 32, 56, 71, 37, 02, 36, 91, 
22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80, 
24, 47, 32, 60, 99, 03, 45, 02, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50, 
32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70, 
67, 26, 20, 68, 02, 62, 12, 20, 95, 63, 94, 39, 63, 08, 40, 91, 66, 49, 94, 21, 
24, 55, 58, 05, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72, 
21, 36, 23, 09, 75, 00, 76, 44, 20, 45, 35, 14, 00, 61, 33, 97, 34, 31, 33, 95, 
78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 03, 80, 04, 62, 16, 14, 09, 53, 56, 92, 
16, 39, 05, 42, 96, 35, 31, 47, 55, 58, 88, 24, 00, 17, 54, 24, 36, 29, 85, 57, 
86, 56, 00, 48, 35, 71, 89, 07, 05, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58, 
19, 80, 81, 68, 05, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 04, 89, 55, 40, 
04, 52, 08, 83, 97, 35, 99, 16, 07, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66, 
88, 36, 68, 87, 57, 62, 20, 72, 03, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69, 
04, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 08, 46, 29, 32, 40, 62, 76, 36, 
20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 04, 36, 16, 
20, 73, 35, 29, 78, 31, 90, 01, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 05, 54, 
01, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 01, 89, 19, 67, 48)



line_of_4 <- function(data, increment, limit = T) {
  largest <- 0
  largest_i <- 0
  for (i in 1:(400-increment*3)) {
    x <- data[i+increment*0:3]
    if(prod(x) > largest & eval(limit)) {largest <- prod(x); largest_i <- i}
  }
  c(largest, largest_i)
}

a <- line_of_4(dat, 20) # down
# passing a suitable limit as an argument restricts the search to adjacent numbers
b <- line_of_4(dat, 1, limit= quote(i%%20 <=17)) # right
c <- line_of_4(dat, 21, limit= quote(i%%20 <=17)) # diagonal left-to-right
d <- line_of_4(dat, 19, limit= quote(i%%20 >=4)) # diagonal right-to-left

max(a[1],b[1],c[1],d[1]) # d is greatest

# solution 11
# diagonal right-to-left from pos 247 is the largest product

```


Problem 12
```{r}
factor_count <- function(x) {
  div <- seq_len(x)
  length(div[x %% div == 0L])
}

i <- 11457
div <- 5
largest <- 0
while (div<=500) {
  i <- i+1
  x <- sum(1:i)
  div <- factor_count(x)
  if(div > largest){largest <- div}
}

x <- 76576500
factor_count(x)
# solution 12
```


Problem 15
```{r}
# option 1: think of the count of possible routes starting from the right-most column. the number of possible routes depends on the count of possible routes for each column of the preceding box.
pathfinder <- function(n) {
  temp <- c(1,2)
  for (i in 2:n) {
    x <- vector(mode='integer', length = length(temp)+1)
    
    for(j in 1:length(x)){
      if(j<=length(x)-2){
        x[j] <- sum(temp[1:j])
      } else if(j<=length(x)-1){
        x[j] <- temp[j]
      } else {
        x[j] <- 2*sum(x[1:(j-1)])
      }
    }
    
    temp <- x
  }
  temp[n+1]
}


# option 2: think of the routes as binary vectors with length 40 and having 20 zeroes and 20 ones
choose(40, 20)
# which is equivalent to
prod(40:21) / (factorial(20))
```
```{r}
factorial(5)
prod(1:5)
```




Problem 16
```{r}
options(scipen = 999)
txt <- as.character(2^1000)
x <- vector(mode='integer', length = nchar(txt))


for(i in 1:length(x)){
  x[i] <- as.integer(substr(txt,i,i))
}
sum(x)
```


Problem 21
```{r}
x <- 10000

sum_of_div <- function(x) {
  sum((1:(x/2))[x %% 1:(x/2) == 0])
}

sumdiv <- vector(mode = "integer", length = x)

for (i in 1:x) {
  sumdiv[i] <- sum_of_div(i)
}

pairind <- vector(mode = "logical", length = x); pairind[1] <- F
for (i in 2:x) {
  if(i != sumdiv[i]){
    pairind[i] <- i == sum_of_div(sum_of_div(i))
  } else {
    pairind[i] <- F # for cases when sum_of_div points to itself
  }
}


sum(sumdiv[pairind]) # solution 21
```

Problem 22
```{r}
txt_raw <- read.delim('p022_names.txt', sep = ",", header = F, stringsAsFactors = F)
t <- as.character(t(txt_raw))
t[which(is.na(t))] <- "NA" # fix the name "NA" being treated as NA
txt <- t[order(t)]
alphabet <- factor(c('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'))

# function to calculate the "alphabetical value" of a given string
pointcount <- function(string) {
  sum <- 0
  for (i in 1:nchar(string)) {
    sum <- sum + which(alphabet == tolower(substr(string, i, i)))
  }
  sum
}

points <- vector(mode = "integer", length = length(txt))
for (i in 1:length(txt)) {
  points[i] <- pointcount(txt[i]) * i # multiply "alphabetical value" with alphabetical position
}

sum(points) # solution 22
```

Problem 23
```{r}
# find abundant numbers
a <- vector(length = 28122)
for (i in 2:28123) {
  a[i-1] <- sum((1:(i-1))[i %% 1:(i-1) == 0]) > i
}
ind <- which(a)+1 # all abundant numbers below 28122

sums <- rep(FALSE, length(a)) # placeholder for sums of abundant numbers
for (ii in 1:length(ind)) {
  for (jj in 1:length(ind)) {
    if(ind[ii]+ind[jj] > 28123) break
     sums[(ind[ii]+ind[jj])] <- TRUE
  }
}

sum(which(!sums)) # solution 23
```

Problem 23
```{r}
a <- c(0:2)




```








